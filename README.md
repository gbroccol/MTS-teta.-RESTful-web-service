# RESTful-Web-Service

### Запуск:
1. http://127.0.0.1:8080/course/interesting


# WEEK 1

## Система контроля версий
## Gitlab
## Agile
## Типы архитектур (посмотреть заметки)

Архитектура приложения, или как сделать так чтобы тебя все любили...

Архитектура — это скелет и многоуровневая структура программного обеспечения с наложением таких характеристик как: гибкость, масштабируемость, возможность реализации, многократность использования и безопасность. Что позволяет в дальнейшем превратить приложение в структурированное решение, которое соответствует как техническим, так и бизнес требованиям.

Критерии хорошей архитектуры:
1. Эффективность системы - программа, должна решать поставленные задачи и хорошо выполнять свои
функции, причем в различных условиях .тем самым принося пользу проекту. Сюда можно отнести
такие характеристики, как надежность, безопасность, производительность, способность
справляться с увеличением нагрузки (масштабируемость), тестируемость, поддерживаемость.

2. Гибкость системы - Любое приложение приходится менять со временем — изменяются требования, добавляются
новые. Чем быстрее и удобнее можно внести изменения в существующий функционал, чем
меньше проблем и ошибок это вызовет — тем гибче и конкурентоспособнее система. Так же
необходимо при проектировании системы использовать дизайн па ттерны. Так же необходимо
правильно проектировать БД, для поддержания гибкости архитектуры приложения.

3. Расширяемость системы - Возможность добавлять в систему новые сущности, интеграции и функции, не нарушая ее основной
структуры. На начальном этапе в систему имеет смысл закладывать лишь основной и самый
необходимый функционал (принцип YAGNI — you ain’t gonna need it, «Вам это не понадобится»).
Основная проблема, которую решает принцип YAGNI — это устранение тяги программистов к
излишней абстракции, к экспериментам «из интереса» и к реализации функционала, который сейчас
не нужен, но, по мнению разработчика, может либо вскоре понадобиться, либо просто будет
полезен, хотя в реальности такого очень часто не происходит. Но при этом архитектура должна
позволять легко наращивать дополнительный функционал по мере необходимости. Чттобы внесение
наиболее вероятных изменений требовало наименьших усилии. Требование, чтобы архитектура
системы обладала гибкостью и расширяемостью (то есть была способна к изменениям и эволюции)
является настолько важным, что оно даже сформулировано в виде отдельного принципа —
«Принципа открытости/закрытости» (Open-Closed Principle — второй из пяти принципов SOLID):
Программные сущности (классы, модули, функции и т.п.) должны быть открытыми для расширения,
но закрытыми для модификации.
Иными словами: Должна быть возможность расширить/изменить поведение системы без
изменения/переписывания уже существующих частей системы.
Это означает, что приложение следует проектировать так, чтобы изменение его поведения и
добавление новой функциональности достигалось бы за счет написания нового кода (расширения), и
при этом не приходилось бы менять уже существующий код. В таком случае появление новых
требований не повлечет за собой модификацию существующей логики, а сможет быть реализовано
прежде всего за счет ее расширения. Именно этот принцип является основой «плагинной
архитектуры» (Plugin Architecture).

4. Масштабируемость процесса разработки - Возможность сократить срок разработки за счёт добавления к проекту новых людей.
Архитектура должна позволять распараллелить процесс разработки, так чтобы
множество людей могли работать над программой одновременно. Для этого
необходимо писать максимально не связанный функционал., т.е. выполнение одной
ветки функционала не должно аффектить выполнение другой ветки функционала.

5. Тестируемость - Код, который легче тестировать, будет содержать меньше ошибок и надежнее работать. Но тесты
не только улучшают качество кода. "Используйте принцип «тестируемости» класса в качестве
«лакмусовой бумажки» хорошего дизайна класса. Даже если вы не напишите ни строчки
тестового кода, ответ на этот вопрос в 90% случаев поможет понять, насколько все
«хорошо» или «плохо» с его дизайном". Существует целая методология разработки программ на
основе тестов, которая так и называется — Разработка через тестирование (Test-Driven
Development, TDD). Для достижение высокой тестируемости кода, рекомендуется пользоваться
определенными правилами :
● Принцип «Не повторяйся» - обобщение методов, переиспользуемых в разных
частях приложения в рамках одного микросервиса(микросервисная архитектура)
● Внедрение зависимости -
● Интерфейсы;
● Контейнеры;
● Модульные тесты с помощью фреймворков для облегчения разработки тестового
окружения.
● Исключить добычу знаний
● Исключить использование больших конструкторов объектов и magic чисел
● Стараться отказаться от использования оператора new в бизнес коде.

6. Переиспользуемость - Возможность повторного использования. Систему желательно проектировать так,
чтобы ее фрагменты можно было повторно использовать в других системах. Для этого
необходимо проектировать систему с учетом ООП и СОЛИД. Использовать паттерны
GoF , например шаблонный метод:
Использование паттерна Шаблонный метод позволяет:
● устранить дублирования кода
● повысить переиспользуемость кода за счет наследования
● сделать код более универсальным и легко изменяемым под новые условия
● шаблонный метод определяет основу алгоритма и позволяет подклассам
переопределить некоторые его шаги, не изменяя структуру в целом. 

7. Сопровождаемость - Хорошо структурированный, читаемый и понятный код. Над программой, как правило, работает
множество людей — одни уходят, приходят новые. После написания сопровождать программу
тоже, как правило, приходится людям, не участвовавшем в ее разработке. Поэтому хорошая
архитектура должна давать возможность относительно легко и быстро разобраться в системе
новым людям. Проект должен быть хорошо структурирован, не содержать дублирования, иметь
хорошо оформленный код и желательно документацию. И по возможности в системе лучше
применять стандартные, общепринятые решения привычные для программистов. Чем экзотичнее
система, тем сложнее ее понять другим (Принцип наименьшего удивления — Principle of least
astonishment. Обычно, он используется в отношении пользовательского интерфейса, но применим
и к написанию кода).


## Spring (Core, MVC, Testing, Security, Data Access, Spring Boot)

[projects](https://spring.io/projects)

### Quick Start

Для создания проекта воспользуемся [spring initializr](https://start.spring.io/). В "Dependencies" добавим "Spring Web", остальные настройки пока трогать не будем.  Скачиваем сгенеренный проект, распаковываем и открываем в любимой IDE (далее в примере будем рассматривать IntelliJ IDEA). Теперь можно перейти к разбору структуры проекта и того, как именно работает Spring Boot.


### Сборка проекта и управление зависимостями

Для начала разберемся, что у нас получилось на выходе из initializr'а. В нашем проекте стандартная структура пакетов Java приложения:

* в папке **src/main/java** содержатся java-классы
* в **src/main/resources** — ресурсы, которые использует наше приложение (HTML-страницы, картинки, проперти и тд);
* **src/test** — тесты

И один класс **DemoApplication.java** с аннотацией **@SpringBootApplication**, добавление которой приводит к созданию всего инфраструктурного кода за нас. Для того чтобы это работало нам нужна библиотека **spring-boot-autoconfigure**, которая в свою очередь зависит от библиотеки **spring-boot**, а она еще от двух и так далее, при этом каждая библиотека имеет версию. Некоторые версии библиотек могут быть несовместимы между собой. У двух разных библиотек могут быть зависимости от третьей библиoтеки, но разных ее версий: первая будет зависеть от одной версии третьей, а вторая - от другой версии третьей.

Даже в таком маленьком примере возникает много проблем. Для их решения были придуманы инструменты управления проектами, мы будем использовать Maven.

#### Что такое Maven?

Maven — это фреймворк для автоматизации сборки проектов на основе описания их структуры в файлах POM (project object model). В корне нашего проекта есть файл **pom.xml** Это и есть главный файл для управления Maven'ом. Давайте разберем, из чего он состоит.

Корневой элемент **project**, в котором прописана xml схема и версия POM.

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"> ... </project>
```

Maven-проекты можно наследовать. Это полезно в ситуации, когда необходимо объединить несколько независимых модулей в один проект. Для этого используется тег parent. В нашем случае spring-boot-starter-parent предоставляет дефолтную конфигурацию для некоторых плагинов и другие настройки по мелочи. При желании можно легко обойтись без него.

 

 **properties** — это переменные, которые потом можно использовать в других частях конфигурации.

 

В Maven каждый проект идентифицируется парой **groupId**, **artifactId**. Во избежание конфликта имён используется следующая конвенция:

* **groupId** - наименование организации (обычно это доменное имя записанное в обратном порядке)
* **artifactId** - название проекта. Внутри тега **version** хранится версия проекта. Тройкой **groupId**, **artifactId**, **version** можно однозначно идентифицировать jar-файл приложения или библиотеки. Пример:

```xml
<groupId>com.example</groupId>
	<artifactId>demo</artifactId>
	<version>0.0.1-SNAPSHOT</version> 
```

Теги **name** и **description** не используются самим Maven'ом. Они нужны для других программистов, чтобы понять о чем этот проект.

 

Тег **packaging** определяет, во что мы будем собирать наше приложение. Возможные варианты - jar, war, ear. Тег является необязательным, значение по умолчанию - jar. Есть отдельно стоящий тип - pom. Он указывает Maven'у, что данный проект является контейнером для подпроектов (submodules). Каждый из подпроектов находится в отдельной поддиректории со своим pom.xml.

 

 Под тегом **dependencies** хранится список всех библиотек (зависимостей), которые используются в проекте. Каждая библиотека идентифицируется так же как и сам проект - тройкой **groupId, artifactId, version**. Можно указать для чего будет использоваться библиотека: например, у spring-boot-starter-test указан тег <scope>test</scope> — это указывает Maven'у, что библиотека нужна только для выполнения тестов. Попробуйте сами добавить новую зависимость (она пригодится в следующем уроке):

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

После добавления зависимости необходимо "обновить" проект, чтобы можно было ей пользоваться. Если работаете в IDEA, то нужно нажать на кнопку **Reload project** во вкладке **Maven**. Также можно просто вызвать **mvnw package**, в процессе сборки проекта Maven обновит зависимости.

 

Тег **build** содержит информацию про саму сборку:

* место, где находятся исходные файлы
* место, где находятся ресурсы 
* используемые плагины


### Пара слов про плагины.
Maven работает на плагинах, каждый из которых выполняет какую-то определенную задачу. Есть плагины, подключенные по умолчанию, например:

* **maven-compile-plugin** - компилирует исходный код проекта
* **maven-jar-plugin** - собирает ваш проект в jar-пакет
* **maven-resources-plugin** - копирует ресурсы вашего приложения в указанную директорию для последующих шагов

Вы можете подключать другие плагины или писать свои собственные — это очень мощный инструмент, позволяющий расширить функционал Maven'а. Например, плагин maven-checkstyle-plugin используется для проверки качества исходного кода, а maven-javadoc-plugin для генерации документации с использованием утилиты javadoc. При описании плагина в pom.xml можно зафиксировать версию плагина, задать ему необходимые параметры и привязать к фазам сборки (то есть указать, когда именно плагин нужно запускать).


### Жизненный цикл сборки

Maven-команды, которые вы запускаете в своем проекте, могут зависеть от других задач. Например, нельзя опубликовать jar-пакет в репозиторий, не собрав его предварительно, или собрать jar, не скомпилировав код. Жизненный цикл — это описание последовательности выполнения команд при сборке.

Основные фазы сборки:

1. compile - компилирование проекта
2. test - тестирование с помощью JUnit тестов
3. package - создание jar-файла (war, ear, в зависимости от типа проекта)
4. integration-test - запуск интеграционных тестов
5. install - копирование jar (war, ear) в локальный репозиторий
6. deploy - публикация файла в удалённый репозиторий.

Если вызвать **mvn package**, то перед созданием jar-файла будут выполняться все предыдущие фазы (compile и test), а фазы integration-test, install, deploy не выполнятся. Если вызвать **mvn deploy**, то выполнятся все приведённые выше фазы.

Особняком стоят фазы clean и site. Они не выполняются, если специально не указаны в строке запуска.

* **clean** - предназначена для удаления всех созданных в процессе сборки артефактов: .class, .jar и др. файлов. В простейшем случае результат — это просто удаление каталога target.
* **site** - предназначена для создания документации.

Команда mvn понимает когда ему передают несколько фаз, поэтому для сборки проекта "с нуля" и создания документации можно вызвать **mvn clean package site**.



### Репозитории

Репозитории - это место, где хранятся артефакты: jar-файлы, pom-файлы, javadoc, исходники. Существует несколько видов репозиториев.

**Локальный репозиторий** по умолчанию расположен в /.m2/repository. Здесь лежат артефакты, которые были скачаны из центрального репозитория либо добавлены другим способом. Например, если набрать команду mvn install в текущем проекте, то соберётся jar, который установится в локальный репозиторий.

**Центральный репозиторий**. Чтобы самому каждый раз не создавать репозиторий, сообщество поддерживает центральный репозиторий. Если для сборки вашего проекта не хватает зависимостей, то они по умолчанию автоматически скачиваются с [Maven Central](http://repo1.maven.org/maven2). В этом репозитории лежат практически все опенсорсные фреймворки и библиотеки. Самому в центральный репозиторий добавить артефакт нельзя. Так как этот репозиторий используют все, то перед тем как туда попадают артефакты, они проверяются, тем более что если артефакт однажды попал в репозиторий, то по правилам изменить его нельзя.

Существуют также и другие репозитории, поддерживаемые сообществом, но их нужно руками добавить в pom файл, чтобы Maven начал искать там артефакты. Вот тут, например, [список](https://mvnrepository.com/repos) популярных репозиториев.

Если вы хотите создать свой репозиторий, содержимое которого вы сможете полностью контролировать (как локальный), и сделать так, чтобы он был доступен не только вам, то для этого есть специальные решения, например [GitHub Packages](https://github.com/features/packages), [Nexus](https://www.sonatype.com/products/repository-pro) или [Artifactory](https://jfrog.com/artifactory/).


### Что за wrapper такой?
В корне проекта также лежит папка .mvn/wrapper, в ней находится jar-файл плагина Maven Wrapper и файл его конфигурации. Maven Wrapper — это простой способ убедиться, что у конечного пользователя вашего билда есть все необходимое, чтобы запустить этот билд. Это может пригодиться, если требуется предоставлять полностью инкапсулированную настройку сборки.

### Есть такая штука Gradle
Maven уже можно считать стандартом в индустрии, его можно встретить в большом количестве open-source продуктов. Но это не единственная система сборки в мире Java. Gradle — автоматическая система сборки и управления зависимостями, построенная на принципах Maven, но предоставляющая [DSL](https://en.wikipedia.org/wiki/Domain-specific_language) на groovy/kotlin для конфигурации проекта, что делает Gradle более мощным и выразительным. Есть отличия и в подходе к управлению жизненным циклом сборки — Gradle использует направленный граф для определения порядка выполнения задач, что позволяет существенно ускорить сборку для крупных многомодульных проектов (так как можно определить изменились ли входные/выходные данные для задачи и если нет, то не выполнять ее).


### Инверсия управления
Прежде чем перейти к разбору деталей работы Spring'а, рассмотрим принципы, лежащие в его основе. Одним из таких является инверсия управления, он же IoC (inversion of control). Инверсия управления является ключевой частью того, что различает фреймворк и библиотеку. Библиотека — это по существу набор функций/классов, которые вы можете вызывать. Каждый вызов выполняет некоторую работу и возвращает управление обратно пользователю. Фреймворк же воплощает в себе некоторый абстрактный дизайн со встроенным поведением. Для того, чтобы использовать его, вы должны добавить свой код в различных местах фреймворка, а код фреймворка впоследствии будет вызывать ваш код. Ваш код получает управление на какое-то время, делает свою работу и возвращает управление обратно фреймфорку. В этом и заключается инверсия управления.

Существуют различные способы подключить ваш код для его дальнейшего вызова. Например, можно использовать замыкания, или же фреймворк может определять события (но тогда код пользователя должен быть подписан на эти события), или фреймворк может определять интерфейс, который ваш код должен будет реализовать для соответствующих вызовов. Например, в JUnit, код фреймворка вызывает методы setUp и tearDown для вас, чтобы создавать и очищать ваш тест. Происходит вызов, ваш код реагирует — это тоже инверсия управления.

IoC — это общий принцип, который используется почти повсеместно. Spring использует IoC для "сборки" приложения из маленьких кусков. Такой паттерн называется внедрение зависимостей, он же Dependency Injection (DI). Давайте разберем как это работает на простом примере. Пусть у нас есть компонент, который умеет находить курсы по имени автора.



```java
public class CourseLister {
    ...
    public List<Course> сoursesByAuthor(String name) {
        List<Course> allCourses = finder.findAll();
        return allCourses.stream().filter(course -> course.getAuthor().equals(name)).collect(Collectors.toList());
    }
}
```


Такая реализация этой функции супер наивная: получаем все курсы от finder'а и просматриваем каждый курс на совпадение его автора с запрашиваемым. Конечно, в продакшене не стоит фильтровать объекты в памяти, а лучше сразу передать параметр в sql-запрос. Но сейчас мы не будем это фиксить, так как хотим обсудить другой вопрос.

Что такое и откуда взялся finder? finder — это та сущность, которая непосредственно отвечает за чтение данных из того места, где они хранятся и поиск по ним (метод findAll, как следует из названия, возвращает просто все, что есть). Мы хотим сделать наш метод сoursesByAuthor полностью независимым от способа и формата хранения курсов в нашей системе, для этого нам нужно иметь возможность быстро и удобно подменять конкретную реализацию finder'а. Любой класс, реализующий finder, должен знать как отвечать на findAll метод. Давайте определим интерфейс этого finder'а:




```java
public interface CourseFinder {
    List<Course> findAll();
}
```

Теперь наши классы хорошо разделены между собой, но в какой-то момент мы должны определиться и создать экземпляр конкретного класса, который будет искать курсы. Давайте добавим это определение в конструктор нашего класса:

```java
public class CourseLister {
    private CourseFinder finder;

    public CourseLister() {
        this.finder = new FileBasedCourseFinder("courses.txt");
    }
    ...
}
```
Пока мы одни работаем с этим кодом все хорошо. Давайте представим ситуацию: кто-то из команды захотел переиспользовать наш код. Но вот не задача, он хранит данные о курсах в другом формате. Это может быть XML, SQL база данных, web сервис и т.д. В таком случае нам нужен другой класс для получения данных. Так как мы абстрагировали наш метод сoursesByAuthor от способа получения курсов, то вносить изменения в него теперь не нужно. Но мы все еще должны каким-то способом указать правильную реализацию finder'а. На диаграмме показаны зависимости для наших классов:

![00img]()

Наш класс зависит от интерфейса CourseFinder и от конкретной его реализации. Хочется, чтоб зависимость была только от интерфейса, в таком виде код будет сильно легче менять или переиспользовать. Как мы можем этого достичь? Так как мы хотим чтобы наш Lister мог работать с любой имплементацией, то эта имплементация должна встраиваться в наш класс где-то выше уровнем, и без нашего ведома. Для решения этой проблемы Spring использует паттерн Dependency Injection.

Основная идея DI заключается в том, что за выбор нужной имплементации отвечает отдельная сущность "сборщик" (Assembler), он же внедряет ее в наш Lister. Диаграмма зависимостей начинает выглядеть так: 

![00img]()

Добавлять зависимость в класс можно разными способами (Constructor Injection, Setter Injection, Interface Injection), но это все детали, не меняющие базовую идею. Перепишем наш пример с использованием этой возможности:



```java
@Component
public class CourseLister {
    private final CourseFinder finder;

    @Autowired
    public CourseLister(CourseFinder finder) {
        this.finder = finder;
    }

    public List<Course> сoursesByAuthor(String name) {
        List<Course> allCourses = finder.findAll();
        return allCourses.stream().filter(course -> course.getAuthor().equals(name)).collect(Collectors.toList());
    }
}
```

В Spring используются аннотации для указания деталей конфигурации того или иного класс. Аннотация **@Component** указывает на то, что объект этого класса должен создавать сборщик. **@Autowired** указывает на то, что в этом месте нужно внедрить зависимость. Теперь наш код полностью изолирован от конкретной реализации finder'а и мы можем его свободно переиспользовать.

Теперь можно перейти к рассмотрению деталей работы Spring изнутри и Spring Boot'а в частности.

### Вместо заключения
Какие проблемы мы решили в нашем коде, использую инструменты DI в Spring?

Нарушение принципа единства ответственности. При подготовке зависимых классов мы должны их создавать, что приводит к зависимости от конкретных реализаций этих классов и сильной привязки к ним. Код инициализации может иногда оказаться больше и сложнее самой бизнес логики, что усложняет в разы работу с кодом, а это никому не нужно, ведь прежде всего нас интересует именно бизнес логика.

DI — не единственный паттерн, позволяющий решать такого рода проблемы, если тема вызвала интерес — можно еще почитать про [Service Locator](https://en.wikipedia.org/wiki/Service_locator_pattern).



```java

```

```java

```

```java

```

```java

```

```java

```


## Spring MVC

