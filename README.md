# RESTful-Web-Service

### Запуск:
1. http://127.0.0.1:8080/course/interesting


# WEEK 1

## Система контроля версий
## Gitlab
## Agile
## Типы архитектур (посмотреть заметки)

Архитектура приложения, или как сделать так чтобы тебя все любили...

Архитектура — это скелет и многоуровневая структура программного обеспечения с наложением таких характеристик как: гибкость, масштабируемость, возможность реализации, многократность использования и безопасность. Что позволяет в дальнейшем превратить приложение в структурированное решение, которое соответствует как техническим, так и бизнес требованиям.

Критерии хорошей архитектуры:
1. Эффективность системы - программа, должна решать поставленные задачи и хорошо выполнять свои
функции, причем в различных условиях .тем самым принося пользу проекту. Сюда можно отнести
такие характеристики, как надежность, безопасность, производительность, способность
справляться с увеличением нагрузки (масштабируемость), тестируемость, поддерживаемость.

2. Гибкость системы - Любое приложение приходится менять со временем — изменяются требования, добавляются
новые. Чем быстрее и удобнее можно внести изменения в существующий функционал, чем
меньше проблем и ошибок это вызовет — тем гибче и конкурентоспособнее система. Так же
необходимо при проектировании системы использовать дизайн па ттерны. Так же необходимо
правильно проектировать БД, для поддержания гибкости архитектуры приложения.

3. Расширяемость системы - Возможность добавлять в систему новые сущности, интеграции и функции, не нарушая ее основной
структуры. На начальном этапе в систему имеет смысл закладывать лишь основной и самый
необходимый функционал (принцип YAGNI — you ain’t gonna need it, «Вам это не понадобится»).
Основная проблема, которую решает принцип YAGNI — это устранение тяги программистов к
излишней абстракции, к экспериментам «из интереса» и к реализации функционала, который сейчас
не нужен, но, по мнению разработчика, может либо вскоре понадобиться, либо просто будет
полезен, хотя в реальности такого очень часто не происходит. Но при этом архитектура должна
позволять легко наращивать дополнительный функционал по мере необходимости. Чттобы внесение
наиболее вероятных изменений требовало наименьших усилии. Требование, чтобы архитектура
системы обладала гибкостью и расширяемостью (то есть была способна к изменениям и эволюции)
является настолько важным, что оно даже сформулировано в виде отдельного принципа —
«Принципа открытости/закрытости» (Open-Closed Principle — второй из пяти принципов SOLID):
Программные сущности (классы, модули, функции и т.п.) должны быть открытыми для расширения,
но закрытыми для модификации.
Иными словами: Должна быть возможность расширить/изменить поведение системы без
изменения/переписывания уже существующих частей системы.
Это означает, что приложение следует проектировать так, чтобы изменение его поведения и
добавление новой функциональности достигалось бы за счет написания нового кода (расширения), и
при этом не приходилось бы менять уже существующий код. В таком случае появление новых
требований не повлечет за собой модификацию существующей логики, а сможет быть реализовано
прежде всего за счет ее расширения. Именно этот принцип является основой «плагинной
архитектуры» (Plugin Architecture).

4. Масштабируемость процесса разработки - Возможность сократить срок разработки за счёт добавления к проекту новых людей.
Архитектура должна позволять распараллелить процесс разработки, так чтобы
множество людей могли работать над программой одновременно. Для этого
необходимо писать максимально не связанный функционал., т.е. выполнение одной
ветки функционала не должно аффектить выполнение другой ветки функционала.

5. Тестируемость - Код, который легче тестировать, будет содержать меньше ошибок и надежнее работать. Но тесты
не только улучшают качество кода. "Используйте принцип «тестируемости» класса в качестве
«лакмусовой бумажки» хорошего дизайна класса. Даже если вы не напишите ни строчки
тестового кода, ответ на этот вопрос в 90% случаев поможет понять, насколько все
«хорошо» или «плохо» с его дизайном". Существует целая методология разработки программ на
основе тестов, которая так и называется — Разработка через тестирование (Test-Driven
Development, TDD). Для достижение высокой тестируемости кода, рекомендуется пользоваться
определенными правилами :
● Принцип «Не повторяйся» - обобщение методов, переиспользуемых в разных
частях приложения в рамках одного микросервиса(микросервисная архитектура)
● Внедрение зависимости -
● Интерфейсы;
● Контейнеры;
● Модульные тесты с помощью фреймворков для облегчения разработки тестового
окружения.
● Исключить добычу знаний
● Исключить использование больших конструкторов объектов и magic чисел
● Стараться отказаться от использования оператора new в бизнес коде.

6. Переиспользуемость - Возможность повторного использования. Систему желательно проектировать так,
чтобы ее фрагменты можно было повторно использовать в других системах. Для этого
необходимо проектировать систему с учетом ООП и СОЛИД. Использовать паттерны
GoF , например шаблонный метод:
Использование паттерна Шаблонный метод позволяет:
● устранить дублирования кода
● повысить переиспользуемость кода за счет наследования
● сделать код более универсальным и легко изменяемым под новые условия
● шаблонный метод определяет основу алгоритма и позволяет подклассам
переопределить некоторые его шаги, не изменяя структуру в целом. 

7. Сопровождаемость - Хорошо структурированный, читаемый и понятный код. Над программой, как правило, работает
множество людей — одни уходят, приходят новые. После написания сопровождать программу
тоже, как правило, приходится людям, не участвовавшем в ее разработке. Поэтому хорошая
архитектура должна давать возможность относительно легко и быстро разобраться в системе
новым людям. Проект должен быть хорошо структурирован, не содержать дублирования, иметь
хорошо оформленный код и желательно документацию. И по возможности в системе лучше
применять стандартные, общепринятые решения привычные для программистов. Чем экзотичнее
система, тем сложнее ее понять другим (Принцип наименьшего удивления — Principle of least
astonishment. Обычно, он используется в отношении пользовательского интерфейса, но применим
и к написанию кода).


## Spring (Core, MVC, Testing, Security, Data Access, Spring Boot)

[projects](https://spring.io/projects)

### Quick Start

Для создания проекта воспользуемся [spring initializr](https://start.spring.io/). В "Dependencies" добавим "Spring Web", остальные настройки пока трогать не будем.  Скачиваем сгенеренный проект, распаковываем и открываем в любимой IDE (далее в примере будем рассматривать IntelliJ IDEA). Теперь можно перейти к разбору структуры проекта и того, как именно работает Spring Boot.


### Сборка проекта и управление зависимостями

Для начала разберемся, что у нас получилось на выходе из initializr'а. В нашем проекте стандартная структура пакетов Java приложения:

* в папке **src/main/java** содержатся java-классы
* в **src/main/resources** — ресурсы, которые использует наше приложение (HTML-страницы, картинки, проперти и тд);
* **src/test** — тесты

И один класс **DemoApplication.java** с аннотацией **@SpringBootApplication**, добавление которой приводит к созданию всего инфраструктурного кода за нас. Для того чтобы это работало нам нужна библиотека **spring-boot-autoconfigure**, которая в свою очередь зависит от библиотеки **spring-boot**, а она еще от двух и так далее, при этом каждая библиотека имеет версию. Некоторые версии библиотек могут быть несовместимы между собой. У двух разных библиотек могут быть зависимости от третьей библиoтеки, но разных ее версий: первая будет зависеть от одной версии третьей, а вторая - от другой версии третьей.

Даже в таком маленьком примере возникает много проблем. Для их решения были придуманы инструменты управления проектами, мы будем использовать Maven.

#### Что такое Maven?

Maven — это фреймворк для автоматизации сборки проектов на основе описания их структуры в файлах POM (project object model). В корне нашего проекта есть файл **pom.xml** Это и есть главный файл для управления Maven'ом. Давайте разберем, из чего он состоит.

Корневой элемент **project**, в котором прописана xml схема и версия POM.

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"> ... </project>
```

Maven-проекты можно наследовать. Это полезно в ситуации, когда необходимо объединить несколько независимых модулей в один проект. Для этого используется тег parent. В нашем случае spring-boot-starter-parent предоставляет дефолтную конфигурацию для некоторых плагинов и другие настройки по мелочи. При желании можно легко обойтись без него.

 

 **properties** — это переменные, которые потом можно использовать в других частях конфигурации.

 

В Maven каждый проект идентифицируется парой **groupId**, **artifactId**. Во избежание конфликта имён используется следующая конвенция:

* **groupId** - наименование организации (обычно это доменное имя записанное в обратном порядке)
* **artifactId** - название проекта. Внутри тега **version** хранится версия проекта. Тройкой **groupId**, **artifactId**, **version** можно однозначно идентифицировать jar-файл приложения или библиотеки. Пример:

```xml
<groupId>com.example</groupId>
	<artifactId>demo</artifactId>
	<version>0.0.1-SNAPSHOT</version> 
```

Теги **name** и **description** не используются самим Maven'ом. Они нужны для других программистов, чтобы понять о чем этот проект.

 

Тег **packaging** определяет, во что мы будем собирать наше приложение. Возможные варианты - jar, war, ear. Тег является необязательным, значение по умолчанию - jar. Есть отдельно стоящий тип - pom. Он указывает Maven'у, что данный проект является контейнером для подпроектов (submodules). Каждый из подпроектов находится в отдельной поддиректории со своим pom.xml.

 

 Под тегом **dependencies** хранится список всех библиотек (зависимостей), которые используются в проекте. Каждая библиотека идентифицируется так же как и сам проект - тройкой **groupId, artifactId, version**. Можно указать для чего будет использоваться библиотека: например, у spring-boot-starter-test указан тег <scope>test</scope> — это указывает Maven'у, что библиотека нужна только для выполнения тестов. Попробуйте сами добавить новую зависимость (она пригодится в следующем уроке):

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

После добавления зависимости необходимо "обновить" проект, чтобы можно было ей пользоваться. Если работаете в IDEA, то нужно нажать на кнопку **Reload project** во вкладке **Maven**. Также можно просто вызвать **mvnw package**, в процессе сборки проекта Maven обновит зависимости.

 

Тег **build** содержит информацию про саму сборку:

* место, где находятся исходные файлы
* место, где находятся ресурсы 
* используемые плагины


### Пара слов про плагины.
Maven работает на плагинах, каждый из которых выполняет какую-то определенную задачу. Есть плагины, подключенные по умолчанию, например:

* **maven-compile-plugin** - компилирует исходный код проекта
* **maven-jar-plugin** - собирает ваш проект в jar-пакет
* **maven-resources-plugin** - копирует ресурсы вашего приложения в указанную директорию для последующих шагов

Вы можете подключать другие плагины или писать свои собственные — это очень мощный инструмент, позволяющий расширить функционал Maven'а. Например, плагин maven-checkstyle-plugin используется для проверки качества исходного кода, а maven-javadoc-plugin для генерации документации с использованием утилиты javadoc. При описании плагина в pom.xml можно зафиксировать версию плагина, задать ему необходимые параметры и привязать к фазам сборки (то есть указать, когда именно плагин нужно запускать).


### Жизненный цикл сборки

Maven-команды, которые вы запускаете в своем проекте, могут зависеть от других задач. Например, нельзя опубликовать jar-пакет в репозиторий, не собрав его предварительно, или собрать jar, не скомпилировав код. Жизненный цикл — это описание последовательности выполнения команд при сборке.

Основные фазы сборки:

1. compile - компилирование проекта
2. test - тестирование с помощью JUnit тестов
3. package - создание jar-файла (war, ear, в зависимости от типа проекта)
4. integration-test - запуск интеграционных тестов
5. install - копирование jar (war, ear) в локальный репозиторий
6. deploy - публикация файла в удалённый репозиторий.

Если вызвать **mvn package**, то перед созданием jar-файла будут выполняться все предыдущие фазы (compile и test), а фазы integration-test, install, deploy не выполнятся. Если вызвать **mvn deploy**, то выполнятся все приведённые выше фазы.

Особняком стоят фазы clean и site. Они не выполняются, если специально не указаны в строке запуска.

* **clean** - предназначена для удаления всех созданных в процессе сборки артефактов: .class, .jar и др. файлов. В простейшем случае результат — это просто удаление каталога target.
* **site** - предназначена для создания документации.

Команда mvn понимает когда ему передают несколько фаз, поэтому для сборки проекта "с нуля" и создания документации можно вызвать **mvn clean package site**.



### Репозитории

Репозитории - это место, где хранятся артефакты: jar-файлы, pom-файлы, javadoc, исходники. Существует несколько видов репозиториев.

**Локальный репозиторий** по умолчанию расположен в /.m2/repository. Здесь лежат артефакты, которые были скачаны из центрального репозитория либо добавлены другим способом. Например, если набрать команду mvn install в текущем проекте, то соберётся jar, который установится в локальный репозиторий.

**Центральный репозиторий**. Чтобы самому каждый раз не создавать репозиторий, сообщество поддерживает центральный репозиторий. Если для сборки вашего проекта не хватает зависимостей, то они по умолчанию автоматически скачиваются с [Maven Central](http://repo1.maven.org/maven2). В этом репозитории лежат практически все опенсорсные фреймворки и библиотеки. Самому в центральный репозиторий добавить артефакт нельзя. Так как этот репозиторий используют все, то перед тем как туда попадают артефакты, они проверяются, тем более что если артефакт однажды попал в репозиторий, то по правилам изменить его нельзя.

Существуют также и другие репозитории, поддерживаемые сообществом, но их нужно руками добавить в pom файл, чтобы Maven начал искать там артефакты. Вот тут, например, [список](https://mvnrepository.com/repos) популярных репозиториев.

Если вы хотите создать свой репозиторий, содержимое которого вы сможете полностью контролировать (как локальный), и сделать так, чтобы он был доступен не только вам, то для этого есть специальные решения, например GitHub Packages, Nexus или Artifactory.


```xml

```

```xml

```

```xml

```


## Spring MVC

