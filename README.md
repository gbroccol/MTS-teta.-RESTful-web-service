# RESTful-Web-Service

### Запуск:
1. http://127.0.0.1:8080/course/interesting


# WEEK 1

## Система контроля версий
## Gitlab
## Agile
## Типы архитектур (посмотреть заметки)

Архитектура приложения, или как сделать так чтобы тебя все любили...

Архитектура — это скелет и многоуровневая структура программного обеспечения с наложением таких характеристик как: гибкость, масштабируемость, возможность реализации, многократность использования и безопасность. Что позволяет в дальнейшем превратить приложение в структурированное решение, которое соответствует как техническим, так и бизнес требованиям.

Критерии хорошей архитектуры:
1. Эффективность системы - программа, должна решать поставленные задачи и хорошо выполнять свои
функции, причем в различных условиях .тем самым принося пользу проекту. Сюда можно отнести
такие характеристики, как надежность, безопасность, производительность, способность
справляться с увеличением нагрузки (масштабируемость), тестируемость, поддерживаемость.

2. Гибкость системы - Любое приложение приходится менять со временем — изменяются требования, добавляются
новые. Чем быстрее и удобнее можно внести изменения в существующий функционал, чем
меньше проблем и ошибок это вызовет — тем гибче и конкурентоспособнее система. Так же
необходимо при проектировании системы использовать дизайн па ттерны. Так же необходимо
правильно проектировать БД, для поддержания гибкости архитектуры приложения.

3. Расширяемость системы - Возможность добавлять в систему новые сущности, интеграции и функции, не нарушая ее основной
структуры. На начальном этапе в систему имеет смысл закладывать лишь основной и самый
необходимый функционал (принцип YAGNI — you ain’t gonna need it, «Вам это не понадобится»).
Основная проблема, которую решает принцип YAGNI — это устранение тяги программистов к
излишней абстракции, к экспериментам «из интереса» и к реализации функционала, который сейчас
не нужен, но, по мнению разработчика, может либо вскоре понадобиться, либо просто будет
полезен, хотя в реальности такого очень часто не происходит. Но при этом архитектура должна
позволять легко наращивать дополнительный функционал по мере необходимости. Чттобы внесение
наиболее вероятных изменений требовало наименьших усилии. Требование, чтобы архитектура
системы обладала гибкостью и расширяемостью (то есть была способна к изменениям и эволюции)
является настолько важным, что оно даже сформулировано в виде отдельного принципа —
«Принципа открытости/закрытости» (Open-Closed Principle — второй из пяти принципов SOLID):
Программные сущности (классы, модули, функции и т.п.) должны быть открытыми для расширения,
но закрытыми для модификации.
Иными словами: Должна быть возможность расширить/изменить поведение системы без
изменения/переписывания уже существующих частей системы.
Это означает, что приложение следует проектировать так, чтобы изменение его поведения и
добавление новой функциональности достигалось бы за счет написания нового кода (расширения), и
при этом не приходилось бы менять уже существующий код. В таком случае появление новых
требований не повлечет за собой модификацию существующей логики, а сможет быть реализовано
прежде всего за счет ее расширения. Именно этот принцип является основой «плагинной
архитектуры» (Plugin Architecture).

4. Масштабируемость процесса разработки - Возможность сократить срок разработки за счёт добавления к проекту новых людей.
Архитектура должна позволять распараллелить процесс разработки, так чтобы
множество людей могли работать над программой одновременно. Для этого
необходимо писать максимально не связанный функционал., т.е. выполнение одной
ветки функционала не должно аффектить выполнение другой ветки функционала.

5. Тестируемость - Код, который легче тестировать, будет содержать меньше ошибок и надежнее работать. Но тесты
не только улучшают качество кода. "Используйте принцип «тестируемости» класса в качестве
«лакмусовой бумажки» хорошего дизайна класса. Даже если вы не напишите ни строчки
тестового кода, ответ на этот вопрос в 90% случаев поможет понять, насколько все
«хорошо» или «плохо» с его дизайном". Существует целая методология разработки программ на
основе тестов, которая так и называется — Разработка через тестирование (Test-Driven
Development, TDD). Для достижение высокой тестируемости кода, рекомендуется пользоваться
определенными правилами :
● Принцип «Не повторяйся» - обобщение методов, переиспользуемых в разных
частях приложения в рамках одного микросервиса(микросервисная архитектура)
● Внедрение зависимости -
● Интерфейсы;
● Контейнеры;
● Модульные тесты с помощью фреймворков для облегчения разработки тестового
окружения.
● Исключить добычу знаний
● Исключить использование больших конструкторов объектов и magic чисел
● Стараться отказаться от использования оператора new в бизнес коде.

6. Переиспользуемость - Возможность повторного использования. Систему желательно проектировать так,
чтобы ее фрагменты можно было повторно использовать в других системах. Для этого
необходимо проектировать систему с учетом ООП и СОЛИД. Использовать паттерны
GoF , например шаблонный метод:
Использование паттерна Шаблонный метод позволяет:
● устранить дублирования кода
● повысить переиспользуемость кода за счет наследования
● сделать код более универсальным и легко изменяемым под новые условия
● шаблонный метод определяет основу алгоритма и позволяет подклассам
переопределить некоторые его шаги, не изменяя структуру в целом. 

7. Сопровождаемость - Хорошо структурированный, читаемый и понятный код. Над программой, как правило, работает
множество людей — одни уходят, приходят новые. После написания сопровождать программу
тоже, как правило, приходится людям, не участвовавшем в ее разработке. Поэтому хорошая
архитектура должна давать возможность относительно легко и быстро разобраться в системе
новым людям. Проект должен быть хорошо структурирован, не содержать дублирования, иметь
хорошо оформленный код и желательно документацию. И по возможности в системе лучше
применять стандартные, общепринятые решения привычные для программистов. Чем экзотичнее
система, тем сложнее ее понять другим (Принцип наименьшего удивления — Principle of least
astonishment. Обычно, он используется в отношении пользовательского интерфейса, но применим
и к написанию кода).


## Spring (Core, MVC, Testing, Security, Data Access, Spring Boot)

[projects](https://spring.io/projects)

### Quick Start

Для создания проекта воспользуемся [spring initializr](https://start.spring.io/). В "Dependencies" добавим "Spring Web", остальные настройки пока трогать не будем.  Скачиваем сгенеренный проект, распаковываем и открываем в любимой IDE (далее в примере будем рассматривать IntelliJ IDEA). Теперь можно перейти к разбору структуры проекта и того, как именно работает Spring Boot.


### Сборка проекта и управление зависимостями

Для начала разберемся, что у нас получилось на выходе из initializr'а. В нашем проекте стандартная структура пакетов Java приложения:

* в папке **src/main/java** содержатся java-классы
* в **src/main/resources** — ресурсы, которые использует наше приложение (HTML-страницы, картинки, проперти и тд);
* **src/test** — тесты

И один класс **DemoApplication.java** с аннотацией **@SpringBootApplication**, добавление которой приводит к созданию всего инфраструктурного кода за нас. Для того чтобы это работало нам нужна библиотека **spring-boot-autoconfigure**, которая в свою очередь зависит от библиотеки **spring-boot**, а она еще от двух и так далее, при этом каждая библиотека имеет версию. Некоторые версии библиотек могут быть несовместимы между собой. У двух разных библиотек могут быть зависимости от третьей библиoтеки, но разных ее версий: первая будет зависеть от одной версии третьей, а вторая - от другой версии третьей.

Даже в таком маленьком примере возникает много проблем. Для их решения были придуманы инструменты управления проектами, мы будем использовать Maven.

#### Что такое Maven?

Maven — это фреймворк для автоматизации сборки проектов на основе описания их структуры в файлах POM (project object model). В корне нашего проекта есть файл **pom.xml** Это и есть главный файл для управления Maven'ом. Давайте разберем, из чего он состоит.

Корневой элемент **project**, в котором прописана xml схема и версия POM.

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"> ... </project>
```

Maven-проекты можно наследовать. Это полезно в ситуации, когда необходимо объединить несколько независимых модулей в один проект. Для этого используется тег parent. В нашем случае spring-boot-starter-parent предоставляет дефолтную конфигурацию для некоторых плагинов и другие настройки по мелочи. При желании можно легко обойтись без него.

 

 **properties** — это переменные, которые потом можно использовать в других частях конфигурации.

 

В Maven каждый проект идентифицируется парой **groupId**, **artifactId**. Во избежание конфликта имён используется следующая конвенция:

* **groupId** - наименование организации (обычно это доменное имя записанное в обратном порядке)
* **artifactId** - название проекта. Внутри тега **version** хранится версия проекта. Тройкой **groupId**, **artifactId**, **version** можно однозначно идентифицировать jar-файл приложения или библиотеки. Пример:

```xml
<groupId>com.example</groupId>
	<artifactId>demo</artifactId>
	<version>0.0.1-SNAPSHOT</version> 
```

Теги **name** и **description** не используются самим Maven'ом. Они нужны для других программистов, чтобы понять о чем этот проект.

 

Тег **packaging** определяет, во что мы будем собирать наше приложение. Возможные варианты - jar, war, ear. Тег является необязательным, значение по умолчанию - jar. Есть отдельно стоящий тип - pom. Он указывает Maven'у, что данный проект является контейнером для подпроектов (submodules). Каждый из подпроектов находится в отдельной поддиректории со своим pom.xml.

 

 Под тегом **dependencies** хранится список всех библиотек (зависимостей), которые используются в проекте. Каждая библиотека идентифицируется так же как и сам проект - тройкой **groupId, artifactId, version**. Можно указать для чего будет использоваться библиотека: например, у spring-boot-starter-test указан тег <scope>test</scope> — это указывает Maven'у, что библиотека нужна только для выполнения тестов. Попробуйте сами добавить новую зависимость (она пригодится в следующем уроке):

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

После добавления зависимости необходимо "обновить" проект, чтобы можно было ей пользоваться. Если работаете в IDEA, то нужно нажать на кнопку **Reload project** во вкладке **Maven**. Также можно просто вызвать **mvnw package**, в процессе сборки проекта Maven обновит зависимости.

 

Тег **build** содержит информацию про саму сборку:

* место, где находятся исходные файлы
* место, где находятся ресурсы 
* используемые плагины


### Пара слов про плагины.
Maven работает на плагинах, каждый из которых выполняет какую-то определенную задачу. Есть плагины, подключенные по умолчанию, например:

* **maven-compile-plugin** - компилирует исходный код проекта
* **maven-jar-plugin** - собирает ваш проект в jar-пакет
* **maven-resources-plugin** - копирует ресурсы вашего приложения в указанную директорию для последующих шагов

Вы можете подключать другие плагины или писать свои собственные — это очень мощный инструмент, позволяющий расширить функционал Maven'а. Например, плагин maven-checkstyle-plugin используется для проверки качества исходного кода, а maven-javadoc-plugin для генерации документации с использованием утилиты javadoc. При описании плагина в pom.xml можно зафиксировать версию плагина, задать ему необходимые параметры и привязать к фазам сборки (то есть указать, когда именно плагин нужно запускать).


### Жизненный цикл сборки

Maven-команды, которые вы запускаете в своем проекте, могут зависеть от других задач. Например, нельзя опубликовать jar-пакет в репозиторий, не собрав его предварительно, или собрать jar, не скомпилировав код. Жизненный цикл — это описание последовательности выполнения команд при сборке.

Основные фазы сборки:

1. compile - компилирование проекта
2. test - тестирование с помощью JUnit тестов
3. package - создание jar-файла (war, ear, в зависимости от типа проекта)
4. integration-test - запуск интеграционных тестов
5. install - копирование jar (war, ear) в локальный репозиторий
6. deploy - публикация файла в удалённый репозиторий.

Если вызвать **mvn package**, то перед созданием jar-файла будут выполняться все предыдущие фазы (compile и test), а фазы integration-test, install, deploy не выполнятся. Если вызвать **mvn deploy**, то выполнятся все приведённые выше фазы.

Особняком стоят фазы clean и site. Они не выполняются, если специально не указаны в строке запуска.

* **clean** - предназначена для удаления всех созданных в процессе сборки артефактов: .class, .jar и др. файлов. В простейшем случае результат — это просто удаление каталога target.
* **site** - предназначена для создания документации.

Команда mvn понимает когда ему передают несколько фаз, поэтому для сборки проекта "с нуля" и создания документации можно вызвать **mvn clean package site**.



### Репозитории

Репозитории - это место, где хранятся артефакты: jar-файлы, pom-файлы, javadoc, исходники. Существует несколько видов репозиториев.

**Локальный репозиторий** по умолчанию расположен в /.m2/repository. Здесь лежат артефакты, которые были скачаны из центрального репозитория либо добавлены другим способом. Например, если набрать команду mvn install в текущем проекте, то соберётся jar, который установится в локальный репозиторий.

**Центральный репозиторий**. Чтобы самому каждый раз не создавать репозиторий, сообщество поддерживает центральный репозиторий. Если для сборки вашего проекта не хватает зависимостей, то они по умолчанию автоматически скачиваются с [Maven Central](http://repo1.maven.org/maven2). В этом репозитории лежат практически все опенсорсные фреймворки и библиотеки. Самому в центральный репозиторий добавить артефакт нельзя. Так как этот репозиторий используют все, то перед тем как туда попадают артефакты, они проверяются, тем более что если артефакт однажды попал в репозиторий, то по правилам изменить его нельзя.

Существуют также и другие репозитории, поддерживаемые сообществом, но их нужно руками добавить в pom файл, чтобы Maven начал искать там артефакты. Вот тут, например, [список](https://mvnrepository.com/repos) популярных репозиториев.

Если вы хотите создать свой репозиторий, содержимое которого вы сможете полностью контролировать (как локальный), и сделать так, чтобы он был доступен не только вам, то для этого есть специальные решения, например [GitHub Packages](https://github.com/features/packages), [Nexus](https://www.sonatype.com/products/repository-pro) или [Artifactory](https://jfrog.com/artifactory/).


### Что за wrapper такой?
В корне проекта также лежит папка .mvn/wrapper, в ней находится jar-файл плагина Maven Wrapper и файл его конфигурации. Maven Wrapper — это простой способ убедиться, что у конечного пользователя вашего билда есть все необходимое, чтобы запустить этот билд. Это может пригодиться, если требуется предоставлять полностью инкапсулированную настройку сборки.

### Есть такая штука Gradle
Maven уже можно считать стандартом в индустрии, его можно встретить в большом количестве open-source продуктов. Но это не единственная система сборки в мире Java. Gradle — автоматическая система сборки и управления зависимостями, построенная на принципах Maven, но предоставляющая [DSL](https://en.wikipedia.org/wiki/Domain-specific_language) на groovy/kotlin для конфигурации проекта, что делает Gradle более мощным и выразительным. Есть отличия и в подходе к управлению жизненным циклом сборки — Gradle использует направленный граф для определения порядка выполнения задач, что позволяет существенно ускорить сборку для крупных многомодульных проектов (так как можно определить изменились ли входные/выходные данные для задачи и если нет, то не выполнять ее).


### Инверсия управления
Прежде чем перейти к разбору деталей работы Spring'а, рассмотрим принципы, лежащие в его основе. Одним из таких является инверсия управления, он же IoC (inversion of control). Инверсия управления является ключевой частью того, что различает фреймворк и библиотеку. Библиотека — это по существу набор функций/классов, которые вы можете вызывать. Каждый вызов выполняет некоторую работу и возвращает управление обратно пользователю. Фреймворк же воплощает в себе некоторый абстрактный дизайн со встроенным поведением. Для того, чтобы использовать его, вы должны добавить свой код в различных местах фреймворка, а код фреймворка впоследствии будет вызывать ваш код. Ваш код получает управление на какое-то время, делает свою работу и возвращает управление обратно фреймфорку. В этом и заключается инверсия управления.

Существуют различные способы подключить ваш код для его дальнейшего вызова. Например, можно использовать замыкания, или же фреймворк может определять события (но тогда код пользователя должен быть подписан на эти события), или фреймворк может определять интерфейс, который ваш код должен будет реализовать для соответствующих вызовов. Например, в JUnit, код фреймворка вызывает методы setUp и tearDown для вас, чтобы создавать и очищать ваш тест. Происходит вызов, ваш код реагирует — это тоже инверсия управления.

IoC — это общий принцип, который используется почти повсеместно. Spring использует IoC для "сборки" приложения из маленьких кусков. Такой паттерн называется внедрение зависимостей, он же Dependency Injection (DI). Давайте разберем как это работает на простом примере. Пусть у нас есть компонент, который умеет находить курсы по имени автора.



```java
public class CourseLister {
    ...
    public List<Course> сoursesByAuthor(String name) {
        List<Course> allCourses = finder.findAll();
        return allCourses.stream().filter(course -> course.getAuthor().equals(name)).collect(Collectors.toList());
    }
}
```


Такая реализация этой функции супер наивная: получаем все курсы от finder'а и просматриваем каждый курс на совпадение его автора с запрашиваемым. Конечно, в продакшене не стоит фильтровать объекты в памяти, а лучше сразу передать параметр в sql-запрос. Но сейчас мы не будем это фиксить, так как хотим обсудить другой вопрос.

Что такое и откуда взялся finder? finder — это та сущность, которая непосредственно отвечает за чтение данных из того места, где они хранятся и поиск по ним (метод findAll, как следует из названия, возвращает просто все, что есть). Мы хотим сделать наш метод сoursesByAuthor полностью независимым от способа и формата хранения курсов в нашей системе, для этого нам нужно иметь возможность быстро и удобно подменять конкретную реализацию finder'а. Любой класс, реализующий finder, должен знать как отвечать на findAll метод. Давайте определим интерфейс этого finder'а:




```java
public interface CourseFinder {
    List<Course> findAll();
}
```

Теперь наши классы хорошо разделены между собой, но в какой-то момент мы должны определиться и создать экземпляр конкретного класса, который будет искать курсы. Давайте добавим это определение в конструктор нашего класса:

```java
public class CourseLister {
    private CourseFinder finder;

    public CourseLister() {
        this.finder = new FileBasedCourseFinder("courses.txt");
    }
    ...
}
```
Пока мы одни работаем с этим кодом все хорошо. Давайте представим ситуацию: кто-то из команды захотел переиспользовать наш код. Но вот не задача, он хранит данные о курсах в другом формате. Это может быть XML, SQL база данных, web сервис и т.д. В таком случае нам нужен другой класс для получения данных. Так как мы абстрагировали наш метод сoursesByAuthor от способа получения курсов, то вносить изменения в него теперь не нужно. Но мы все еще должны каким-то способом указать правильную реализацию finder'а. На диаграмме показаны зависимости для наших классов:

![00](https://github.com/gbroccol/RESTful-Web-Service/blob/main/tutorial_img/00img.png)

Наш класс зависит от интерфейса CourseFinder и от конкретной его реализации. Хочется, чтоб зависимость была только от интерфейса, в таком виде код будет сильно легче менять или переиспользовать. Как мы можем этого достичь? Так как мы хотим чтобы наш Lister мог работать с любой имплементацией, то эта имплементация должна встраиваться в наш класс где-то выше уровнем, и без нашего ведома. Для решения этой проблемы Spring использует паттерн Dependency Injection.

Основная идея DI заключается в том, что за выбор нужной имплементации отвечает отдельная сущность "сборщик" (Assembler), он же внедряет ее в наш Lister. Диаграмма зависимостей начинает выглядеть так: 

![01](https://github.com/gbroccol/RESTful-Web-Service/blob/main/tutorial_img/01img.png)

Добавлять зависимость в класс можно разными способами (Constructor Injection, Setter Injection, Interface Injection), но это все детали, не меняющие базовую идею. Перепишем наш пример с использованием этой возможности:



```java
@Component
public class CourseLister {
    private final CourseFinder finder;

    @Autowired
    public CourseLister(CourseFinder finder) {
        this.finder = finder;
    }

    public List<Course> сoursesByAuthor(String name) {
        List<Course> allCourses = finder.findAll();
        return allCourses.stream().filter(course -> course.getAuthor().equals(name)).collect(Collectors.toList());
    }
}
```

В Spring используются аннотации для указания деталей конфигурации того или иного класс. Аннотация **@Component** указывает на то, что объект этого класса должен создавать сборщик. **@Autowired** указывает на то, что в этом месте нужно внедрить зависимость. Теперь наш код полностью изолирован от конкретной реализации finder'а и мы можем его свободно переиспользовать.

Теперь можно перейти к рассмотрению деталей работы Spring изнутри и Spring Boot'а в частности.

### Вместо заключения
Какие проблемы мы решили в нашем коде, использую инструменты DI в Spring?

Нарушение принципа единства ответственности. При подготовке зависимых классов мы должны их создавать, что приводит к зависимости от конкретных реализаций этих классов и сильной привязки к ним. Код инициализации может иногда оказаться больше и сложнее самой бизнес логики, что усложняет в разы работу с кодом, а это никому не нужно, ведь прежде всего нас интересует именно бизнес логика.

DI — не единственный паттерн, позволяющий решать такого рода проблемы, если тема вызвала интерес — можно еще почитать про [Service Locator](https://en.wikipedia.org/wiki/Service_locator_pattern).



### Spring 

Небольшая историческая справка. Когда-то давно, еще компания Sun представила спецификацию JavaBeans. Это набор соглашений, которых следует придерживаться при написании классов. Например, у всех филдов должны быть сеттеры и геттеры в формате setX и getX соответственно. Это нужно в первую очередь для создателей фреймворков, так как дает определенные гарантии при работе с пользовательски кодом. Отсюда пошло, что объекты в Spring'е называются Beans, а их описание BeanDefinition.

Spring Core — очень комплексная вещь, состоящая из многих кусков, поэтому дальше будет очень упрощенное описание его работы. В действительности же все, как всегда, немного сложнее.

Нам нужен некий сборщик (в Spring это BeanFactory), который может создать за нас наши бины, внедрить в них зависимости и правильно их настроить. Место для хранения всех бинов называется ApplicationContext. Если очень сильно упрощать, то можно думать об нем как о хешмапе, в которой ключем является имя бина, а значением — созданный и настроенный объект. Последняя важная часть в этом процессе — это конфигурация приложения. Spring поддерживает разные варианты конфигураций - XML, Componet Scan, Java Config и некоторые другие. Хотя некоторые из них морально устарели (например, xml), все равно бывает нужно понимать что происходит, например, при работе с легаси проектом. Дальше в примерах мы будем использовать Annotation based подход к конфигурации.

Итак, наша задача — это собрать приложение ("поднять контекст"). Основные этапы в этом процессе следующие:

* Распарсить конфигурацию. За это отвечает BeanDefinitionReader. Основная задача этого этапа — собрать вместе все декларации бинов, описанные вами. 
* Настроить конфигурацию. BeanFactoryPostProcessor. На этом этапе в распаршенное описание могут вноситься изменения. Например, именно на этом этапе происходит замена пропертей на их реальные значения. (Дальше будет подробнее про это рассказано)
* Создание бинов. По заданным описаниям BeanFactory создает уже настоящие объекты для нашего приложения.
* Настройка созданных бинов. BeanPostProcessor. На этом этапе происходит донастройка бинов. Может быть сгенерен дополнительный код и добавлен к вашему.

Необходимости понимать в деталях что и на каком уровне происходит для повседневной работы нет. Главное знать, что нет никакой магии и это просто "конвейер", который собирает ваш код в готовое приложение.


### Что такое Spring Boot?
В какой-то момент конфигурация Spring'а стала сложной задачей сама по себе. Для того чтобы облегчить жизнь разработчикам и снять с них головную боль от настройки проекта, был разработан Spring Boot. Что же он умеет?

1. Приносит в проект набор зависимостей (через наследование в pom-файлах). Эти зависимости собраны и протестированы командой разработки Spring'а, поэтому вам не надо думать над вопросом "а какую же версию очередной библиотеки выбрать чтобы она была совместима с остальными?". Тут есть небольшая особенность, которую мы не обсудили раньше в части про Maven. Спринг знает какая версия будет работать "хорошо". Но чтобы не тащить тысячи либ в каждый проект, он указывает это как хинты. Можно указать зависимость без версии и тогда версия возьмется из этого хинта. Вам понадобился kafka-клиент в вашем проекте? Просто добавляете org.springframework.kafka:spring-kafka в зависимости проекта, а подходящая версия выберется автоматически.
2. 95% инфраструктурных бинов настраиваются однотипным образом. DataSource, EntitymanagerFactory, TransactionManager — все эти сущности обычно одинаковы в настройке и требуют осмысленных изменений только в специфичных задачах. Сюда же можно отнести настройки бинов MVC фреймворка - ViewResolver, MessageSource и т.д. Для того чтобы не писать один и тот же код из проекта в проект в Spring Boot есть механизм SpringBootStarter'ов. Каждый из страртеров создает некоторый набор преднастроенных бинов за вас и помещает их в контекст, а вы уже можете спокойно ими пользоваться в вашем коде.
3. Spring Boot предоставляет простую возможность для кастомизации автонастроенных бинов. Не хотите класть thymeleaf-темплейты в /WEB-INF/views/, а вместо этого держать их в /WEB-INF/templates/? Это делается добавлением одной строчки, просто надо переопределить переменную в своем проекте.


Приведем небольшой пример того, сколько же настроек приносит с собой Spring Boot. Немного изменим код в нашем проекте и поставим точку остановки в main методе как на скриншоте: 

![03](https://github.com/gbroccol/RESTful-Web-Service/blob/main/tutorial_img/03.png)

и посмотрим сколько бинов создалось в нашем контексте:

![04](https://github.com/gbroccol/RESTful-Web-Service/blob/main/tutorial_img/04.png)

То есть в приложение состоящем из одной строчки SpringApplication.run(DemoApplication.class, args)Spring Boot создал и настроил за нас 132 инфраструктурных бина. И это не предел, существуют много разных стартеров под разные задачи, которые можно добавить в свой проект.



### Пример простого приложения с использованием Spring Boot

Напишем немного кода и посмотрим как он запускается в Spring Boot'е. Использовать будем уже знакомый нам пример с CourseLister. Создайте структуру каталогов как на скриншоте: 

![05](https://github.com/gbroccol/RESTful-Web-Service/blob/main/tutorial_img/05.png)

Давайте разбираться что у нас есть:


* **DemoApplication** — стартовая точка нашего приложения. Создает Spring-контекст. Обычно помещается в корневом каталоге (дальше объясним почему это важно)
	```java
	@SpringBootApplication
	public class DemoApplication {

	    public static void main(String[] args) {
		SpringApplication.run(DemoApplication.class, args);
	    }
	}
	```

* **CourseController** — просто rest http endpoint, умеет отдавать список интересных курсов по адресу /course/interesting

	```java
	@RestController
	@RequestMapping("/course")
	public class CourseController {
	    @Autowired
	    private CourseLister courseLister;
	    @Autowired
	    private StatisticsCounter statisticsCounter;

	    @GetMapping("/interesting")
	    public List<Course> getInterestingCourses() {
		statisticsCounter.countHandlerCall();
		// У нас есть бизнес инсайт, что все интересные курсы написал Вася
		return courseLister.coursesByAuthor("Вася");
	    }
	}
	```

* **Course** — доменный объект, описывающий наш курс

	```java
	public class Course {
	    private Long id;
	    private String author;
	    private String title;

	    public Course() {
	    }

	    public Course(Long id, String author, String title) {
		this.id = id;
		this.author = author;
		this.title = title;
	    }

	    public Long getId() {
		return id;
	    }

	    public void setId(Long id) {
		this.id = id;
	    }

	    public String getAuthor() {
		return author;
	    }

	    public void setAuthor(String author) {
		this.author = author;
	    }

	    public String getTitle() {
		return title;
	    }

	    public void setTitle(String title) {
		this.title = title;
	    }
	}
	```

* **CourseLister, CourseRepository и MemoryBasedCourseRepository** - первый компонент мы начали обсуждать в теме про IoC

**CourseLister**

	```java
	@Component
	public class CourseLister {
	    private final CourseRepository repository;

	    @Autowired
	    public CourseLister(CourseRepository repository) {
		this.repository = repository;
	    }

	    public List<Course> coursesByAuthor(String name) {
		List<Course> allCourses = repository.findAll();
		return allCourses.stream().filter(course -> course.getAuthor().equals(name)).collect(Collectors.toList());
	    }
	}
	```

**CourseRepository**

	```java
	public interface CourseRepository {
	    List<Course> findAll();

	    Optional<Course> findById(long id);

	    void save(Course course);

	    void delete(long id);

	    List<Course> findByTitleWithPrefix(String prefix);
	}
	```

**MemoryBasedCourseRepository**


	```java
	@Component
	public class MemoryBasedCourseRepository implements CourseRepository {

	    private final Map<Long, Course> courseMap = new ConcurrentHashMap<>();
	    private final AtomicLong identity = new AtomicLong();

	    @PostConstruct
	    public void init() {
		save(new Course(null, "Вася", "Основы программирования на джава"));
		save(new Course(null, "Вася", "Базы данных для самых маленьких"));
		save(new Course(null, "Петя", "Скучный маркетинг"));
	    }

	    @Override
	    public List<Course> findAll() {
		return new ArrayList<>(courseMap.values());
	    }

	    @Override
	    public Optional<Course> findById(long id) {
		return Optional.ofNullable(courseMap.get(id));
	    }

	    @Override
	    public void save(Course course) {
		if (course.getId() == null) {
		    course.setId(identity.incrementAndGet());
		}
		courseMap.put(course.getId(), course);
	    }

	    @Override
	    public void delete(long id) {
		courseMap.remove(id);
	    }

	    @Override
	    public List<Course> findByTitleWithPrefix(String prefix) {
		return courseMap.values()
			.stream().filter(course -> course.getTitle().startsWith(prefix))
			.collect(Collectors.toList());
	    }
	}
	```

* **StatisticsCounter** — класс, умеющий собирать статистику; в супер простой реализации пишет в лог, что где-то произошел вызов

	```java
	public class StatisticsCounter {
	    private static final Logger log = LoggerFactory.getLogger(StatisticsCounter.class);

	    public void countHandlerCall() {
		log.info("Кто-то дернул нашу ручку!");
	    }
	}
	```

* **StatisticsConfig** — один из способов создавать бины, подробности дальше

	```java
	@Configuration
	public class StatisticsConfig {
	    @Bean
	    public StatisticsCounter statisticsCounter() {
		return new StatisticsCounter();
	    }
	}
	```


### Как запустить приложение
Когда вы работаете в IDE (для примера будем рассматривать IntelliJ IDEA), то идем во вкладку **Run** и там выбираем **Edit Configurations**..., там нажимаем на + и выбираем из списка Spring Boot. Теперь осталось дать новой конфигурации имя и указать стартовый класс нашего приложения (Main class), в нашем случае это **com.example.demo.DemoApplication**. Теперь все готово и можно запустить выбранную конфигурацию из IDE.

Приложение также можно запустить и без использования IDE, в Maven существует отдельный плагин для таких целей. Можно вызвать **mvnw clean spring-boot:run**. Так как у вас всего один класс с **main** методом в приложение, то Spring Boot сам найдет его и запустит. Команду **clean** здесь почистит старые артифакты сборки, из-за этого **spring-boot:run** заново соберет проект, тем самым можно убедиться что была запущена последняя версия кода.

Запускаем наше приложение и пробуем сходить на **http://localhost:8080/course/interesting**. Видим в ответе список интересных курсов. Теперь посмотрим в деталях как работает Spring Boot.

По умолчанию Spring Boot использует Component Scan для поиска и создания бинов. Это механизм, который сканирует файлы и ищет в них подсказки про то, какие именно бины надо создать.

**В каком месте Spring Boot будет искать файлы?** По умолчанию это пакет, в котором он запущен, плюс рекурсивно все подпакеты. Именно поэтому важно место расположения основного класса нашего приложения.

Как Spring Boot понимает какой бин создавать? Для этого мы используем аннотации, в простом виде **@Component** или **@Service**. Чуть сложнее — **@Controller** и **@RestController**. Дальше в уроках мы будем много их использовать поэтому пару слов про разницу между этими двумя анотациями:

* **@Controller** используется чтобы пометить класс как Spring MVC Controller
* **@RestController** это комбинация из двух аннотаций @Controller и @ResponseBody
* **@ResponseBody** обозначает что возвращаемый объект будет серилизован и передан в HTTP response body. Это также означает, что @RestController нельзя использовать в MVC, так как View здесь игнорируется и сразу возращается доменный объект. Объекты по умолчанию сериализуются в JSON, но вы можете поменять это на любой другой формат, например XML или YAML.


Так как мы пока не обсуждали Spring MVC, то **CourseController** пока размечен анотацией **@RestController**. В следующем уроке мы это поменяем.

Как мы уже обсуждали ранее, есть и другие способы для описания контекста. Например, Java Config. Можно комбинировать эти способы — часть бинов описывать аннотациями на классах, часть через Java Config'и (можно еще и xml описание бинов добавить в проект, но делать этого мы не будем). В нашем примере есть класс StatisticsConfig. Аннотация @Configuration указывает Spring'у, что это Java Config и из него можно создать несколько бинов. @Bean указывает что данный метод создает бин. В таком простом примере разницы между этими двумя вариантами определения бинов нет. И лучше использовать @Component. Но бывают ситуации, когда нужно произвести специфичную настройку в момент создания бина, тогда гибкость джава конфигурации имеет большое значение (Это обычный java-код, можно делать что душе угодно).

Следующая важная для нас аннотация **@Autowired**. Она указывает спрингу, что здесь надо добавить зависимость. Можно использовать в конструкторе (CourseLister) или над филдами (CourseController). Лучше в рабочем коде использовать внедрение через конструктор, на то есть несколько причин, тут подробно не будем это обсуждать.

**Как Spring узнает какой объект нужно внедрить в качестве зависимости?** Все просто, он ищет подходящий по типу класс среди бинов в контексте. Что будет если в контексте несколько бинов с одинаковым типом? Будет выброшено исключение о том, что Spring не может понять какая зависимость вам нужна. Для таких ситуаций нужно добавить аннотацию **@Qualifier("coolBeanName")**, она дополнительно сообщает что нужно брать бин с указанным именем.



### Profiles

Напоследок рассмотрим еще один крайне полезный механизм. Типичная история для любого проекта — иметь несколько сред, где он будет выполняться. В минимальной конфигурации их обычно три:

* Продакшен
* Тестинг
* Локальная машина разработчика

Допустим ваш код хранит данные в БД и умеет их изменять. Очевидно, что данные для тестирования и боевые данные нашего приложения в проде должны храниться на разных машинах. Для локального использования можно вообще хранить все в памяти. Как нам сделать так, чтобы один и тот же код можно было запускать в разных средах и все работало без особых дополнительных усилий?

Для этого в Spring'е существует механизм привязки бина к профайлу. При объявлении бина нужно добавить к нему аннотацию @Profile("<profile name>") и установить активный профайл. Существует много способов это сделать (как и для всего в Spring'е :)). Обычно используют jvm ключ -Dspring.profiles.active=<profile name>. Теперь когда вы запустите приложение в проде (с указанием профайла "prod"), Spring добавит в контекст только бины привязанные к данному контексту. Если у бина не указан профайл, то такое бин будет создаваться всегда.


	
	
## Трехслойная архитектура

![]()
    
1. Web layer - принимает запросы
2. Service Layer - бизнес-логика
3. Repository Layer - работа с БД




```java

```


```java

```


```java

```





## Spring MVC

	
	
	
	
	
	
## Links	
* [Антон Архипов — Эффективная работа с IDE(A)](https://www.youtube.com/watch?v=_rj7dx6c5R8)

